package setting

import (
	"fmt"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"log"
	"strings"
	"telegramBot/model"
	"telegramBot/services"
	"telegramBot/utils"
)

var userCheckSetting model.UserCheck

// Ê®°ÂùóÂÖ•Âè£
func UserCheckHandler(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	data := update.CallbackQuery.Data
	query := strings.Split(data, ":")
	cmd := query[0]

	if cmd == "user_check_menu" {
		userCheckMenu(update, bot)

	} else if cmd == "user_check_name" {
		nameCheck(update, bot)

	} else if cmd == "user_check_username" {
		userNameCheck(update, bot)

	} else if cmd == "user_check_icon" {
		iconCheck(update, bot)

	} else if cmd == "user_check_subscribe" {
		subscribeAddMenu(update, bot)

	} else if cmd == "user_check_black_list" {
		blackUserList(update, bot)

	} else if cmd == "user_check_black_add" {
		blackUserAdd(update, bot)

	}
}

// Áî®Êà∑Ê£ÄÊü•ËèúÂçï
func userCheckMenu(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	err := services.GetModelData(utils.GroupInfo.GroupId, &userCheckSetting)
	fmt.Println("userCheckSetting-query", userCheckSetting)

	var btns [][]model.ButtonInfo
	utils.Json2Button2("./config/userCheck.json", &btns)

	var rows [][]model.ButtonInfo
	for i := 0; i < len(btns); i++ {
		btnArray := btns[i]
		var row []model.ButtonInfo
		for j := 0; j < len(btnArray); j++ {
			btn := btnArray[j]
			updateUserCheckButtonStatus(&btn)
			row = append(row, btn)
		}
		rows = append(rows, row)
	}

	keyboard := utils.MakeKeyboard(rows)
	utils.UserCheckMenuMarkup = keyboard

	//Ë¶ÅËØªÂèñÁî®Êà∑ËÆæÁΩÆÁöÑÊï∞ÊçÆ
	content := updateUserSettingMsg()
	msg := tgbotapi.NewEditMessageTextAndMarkup(update.CallbackQuery.Message.Chat.ID, update.CallbackQuery.Message.MessageID, content, keyboard)
	_, err = bot.Send(msg)
	if err != nil {
		log.Println(err)
	}
}

// Áä∂ÊÄÅÂ§ÑÁêÜ-ÂêçÂ≠óÊ£ÄÊü•
func nameCheck(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	userCheckSetting.NameCheck = !userCheckSetting.NameCheck
	if userCheckSetting.NameCheck {
		utils.UserCheckMenuMarkup.InlineKeyboard[0][0].Text = "‚úÖÂøÖÈ°ªËÆæÁΩÆÂêçÂ≠ó"
	} else {
		utils.UserCheckMenuMarkup.InlineKeyboard[0][0].Text = "‚ùåÂøÖÈ°ªËÆæÁΩÆÂêçÂ≠ó"
	}

	content := updateUserSettingMsg()
	msg := tgbotapi.NewEditMessageTextAndMarkup(update.CallbackQuery.Message.Chat.ID, update.CallbackQuery.Message.MessageID, content, utils.UserCheckMenuMarkup)
	_, err := bot.Send(msg)
	if err != nil {
		log.Println(err)
	}
}

// Áä∂ÊÄÅÂ§ÑÁêÜ-Áî®Êà∑ÂêçÊ£ÄÊü•
func userNameCheck(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	userCheckSetting.UserNameCheck = !userCheckSetting.UserNameCheck
	if userCheckSetting.UserNameCheck {
		utils.UserCheckMenuMarkup.InlineKeyboard[0][1].Text = "‚úÖÂøÖÈ°ªËÆæÁΩÆÁî®Êà∑Âêç"
	} else {
		utils.UserCheckMenuMarkup.InlineKeyboard[0][1].Text = "‚ùåÂøÖÈ°ªËÆæÁΩÆÁî®Êà∑Âêç"
	}

	content := updateUserSettingMsg()
	msg := tgbotapi.NewEditMessageTextAndMarkup(update.CallbackQuery.Message.Chat.ID, update.CallbackQuery.Message.MessageID, content, utils.UserCheckMenuMarkup)
	_, err := bot.Send(msg)
	if err != nil {
		log.Println(err)
	}
}

// Áä∂ÊÄÅÂ§ÑÁêÜ-Â§¥ÂÉèÊ£ÄÊü•
func iconCheck(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	userCheckSetting.IconCheck = !userCheckSetting.IconCheck
	if userCheckSetting.IconCheck {
		utils.UserCheckMenuMarkup.InlineKeyboard[1][0].Text = "‚úÖÂøÖÈ°ªËÆæÁΩÆÂ§¥ÂÉè"
	} else {
		utils.UserCheckMenuMarkup.InlineKeyboard[1][0].Text = "‚ùåÂøÖÈ°ªËÆæÁΩÆÂ§¥ÂÉè"
	}

	content := updateUserSettingMsg()
	msg := tgbotapi.NewEditMessageTextAndMarkup(update.CallbackQuery.Message.Chat.ID, update.CallbackQuery.Message.MessageID, content, utils.UserCheckMenuMarkup)
	_, err := bot.Send(msg)
	if err != nil {
		log.Println(err)
	}
}

// Áä∂ÊÄÅÂ§ÑÁêÜ-ËÆ¢ÈòÖÊ£ÄÊü•
func subscribeAddMenu(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	msg := tgbotapi.NewMessage(update.CallbackQuery.Message.Chat.ID, "üî¶ Áî®Êà∑Ê£ÄÊü•\n\n"+
		"Áæ§ÊàêÂëòÂøÖÈ°ªËÆ¢ÈòÖÊåáÂÆöÈ¢ëÈÅì(ÊàñÂä†ÂÖ•ÊåáÂÆöÁæ§)ÂêéËé∑ÂæóÂèëË®ÄÊùÉÈôêÔºåÂπ∂‰∏îÊú∫Âô®‰∫∫Ë¶ÅÂú®ËØ•È¢ëÈÅì(Áæ§ÁªÑ)‰∏≠\n\n"+
		"üëâËØ∑ËæìÂÖ•È¢ëÈÅìÊàñÁæ§ÁªÑÂú∞ÂùÄÔºåÊ†ºÂºèÔºöhttps://t.me/[ÂÖ¨ÂºÄÈìæÊé•]")
	keyboard := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ËøîÂõû"),
		))

	msg.ReplyMarkup = keyboard
	msg.ReplyMarkup = tgbotapi.ForceReply{
		ForceReply: true,
	}
	_, err := bot.Send(msg)
	if err != nil {
		return
	}
}

func SubscribeAddResult(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	//Âà§Êñ≠ËøîÂõûÁöÑÊï∞ÊçÆÊòØÂê¶ÊòØ‰ª•https://t.meÂºÄÂ§¥
	if !strings.HasPrefix(update.Message.Text, "https://t.me/") {
		msg := tgbotapi.NewMessage(update.Message.Chat.ID, "üî¶ Áî®Êà∑Ê£ÄÊü•\n\n"+
			"Ê†ºÂºèÊúâËØØÔºåËØ∑ÈáçÊñ∞ËæìÂÖ•\n\n"+
			"üëâËØ∑ËæìÂÖ•È¢ëÈÅìÊàñÁæ§ÁªÑÂú∞ÂùÄÔºåÊ†ºÂºèÔºöhttps://t.me/[ÂÖ¨ÂºÄÈìæÊé•]")
		keyboard := tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("ËøîÂõû"),
			))

		msg.ReplyMarkup = keyboard
		msg.ReplyMarkup = tgbotapi.ForceReply{
			ForceReply: true,
		}
		_, err := bot.Send(msg)
		if err != nil {
			return
		}
		return
	}
	//Âà§Êñ≠ÂΩìÂâçÊú∫Âô®‰∫∫ÊòØÂê¶Âú®Ëøô‰∏™È¢ëÈÅì‰∏≠
	content := "‚úÖËÆæÁΩÆÊàêÂäü"
	btn1 := model.ButtonInfo{
		Text:    "ËøîÂõû",
		Data:    "user_check_menu",
		BtnType: model.BtnTypeData,
	}
	row1 := []model.ButtonInfo{btn1}
	rows := [][]model.ButtonInfo{row1}
	keyboard := utils.MakeKeyboard(rows)
	userCheckSetting.SubScribe = true
	userCheckSetting.ChannelAddr = update.Message.Text
	updateUserSettingMsg()
	msg := tgbotapi.NewMessage(update.Message.Chat.ID, content)
	msg.ReplyMarkup = keyboard
	_, err = bot.Send(msg)
	if err != nil {
		log.Println(err)
	}
}

// ÈªëÂêçÂçïÁî®Êà∑ÈÄªËæë-ÂàóË°®
func blackUserList(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	words := strings.Split(userCheckSetting.BlackUserList, "&")

	count := len(words)
	if len(words) == 1 && words[0] == "" {
		count = 0
	}
	content := fmt.Sprintf("üî¶ Áî®Êà∑Ê£ÄÊü•\n\n‚õîÔ∏è Á¶ÅÊ≠¢ÂåÖÂê´ÂêçÂ≠ó   Â∑≤Ê∑ªÂä†Á¶ÅÊ≠¢ÂêçÂçïÔºö%dÊù°\n\n", count)
	for _, word := range words {
		content = content + fmt.Sprintf("- %s\n", word)
	}

	btn1 := model.ButtonInfo{
		Text:    "‚ûïÊ∑ªÂä†ÈªëÂêçÂçï",
		Data:    "user_check_black_add",
		BtnType: model.BtnTypeData,
	}

	btn2 := model.ButtonInfo{
		Text:    "ËøîÂõû",
		Data:    "user_check_menu",
		BtnType: model.BtnTypeData,
	}
	row1 := []model.ButtonInfo{btn1, btn2}
	rows := [][]model.ButtonInfo{row1}
	keyboard := utils.MakeKeyboard(rows)

	updateUserSettingMsg()
	msg := tgbotapi.NewEditMessageTextAndMarkup(update.CallbackQuery.Message.Chat.ID, update.CallbackQuery.Message.MessageID, content, keyboard)
	_, err := bot.Send(msg)
	if err != nil {
		log.Println(err)
	}
}

// ÈªëÂêçÂçïÁî®Êà∑ÈÄªËæë-Ê∑ªÂä†
func blackUserAdd(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	msg := tgbotapi.NewMessage(update.CallbackQuery.Message.Chat.ID, "üîá ÈªëÂêçÂçï\\n\\nüëâËØ∑ËæìÂÖ•Ë¶ÅÁ¶ÅÊ≠¢ÁöÑÂêçÂ≠ó(‰∏ÄË°å‰∏Ä‰∏™)")
	keybord := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ËøîÂõû"),
		))

	msg.ReplyMarkup = keybord
	msg.ReplyMarkup = tgbotapi.ForceReply{
		ForceReply: true,
	}
	bot.Send(msg)
}

// ÈªëÂêçÂçïÁî®Êà∑ÈÄªËæë-Ê∑ªÂä†ÂèçÈ¶à
func BlackUserAddResult(update *tgbotapi.Update, bot *tgbotapi.BotAPI) {
	if len(userCheckSetting.BlackUserList) > 0 {
		userCheckSetting.BlackUserList = userCheckSetting.BlackUserList + "&" + update.Message.Text
	} else {
		userCheckSetting.BlackUserList = update.Message.Text
	}

	words := strings.Split(userCheckSetting.BlackUserList, "&")

	content := fmt.Sprintf("Â∑≤Ê∑ªÂä† %d ‰∏™ÈªëÂêçÂçï:\n", len(words))
	for _, word := range words {
		content = fmt.Sprintf("%s\n - %s", content, word)
	}

	btn1 := model.ButtonInfo{
		Text:    "ËøîÂõû",
		Data:    "user_check_menu",
		BtnType: model.BtnTypeData,
	}
	btn2 := model.ButtonInfo{
		Text:    "ÁªßÁª≠Ê∑ªÂä†",
		Data:    "user_check_black_add",
		BtnType: model.BtnTypeData,
	}
	row1 := []model.ButtonInfo{btn1, btn2}
	rows := [][]model.ButtonInfo{row1}
	keyboard := utils.MakeKeyboard(rows)
	updateUserSettingMsg()
	msg := tgbotapi.NewMessage(update.Message.Chat.ID, content)
	msg.ReplyMarkup = keyboard
	_, err := bot.Send(msg)
	if err != nil {
		log.Println(err)
	}
}

// ÈÖçÁΩÆÊï∞ÊçÆÊõ¥Êñ∞
func updateUserSettingMsg() string {
	content := "üî¶ Áî®Êà∑Ê£ÄÊü•\n\nÂú®Áî®Êà∑ËøõÂÖ•Áæ§ÁªÑÂíåÂèëÈÄÅÊ∂àÊÅØÊó∂ËøõË°åÊ£ÄÊü•ÂíåÂ±èËîΩ„ÄÇ\n\n"
	punishMsg := "ÊÉ©ÁΩöÊé™ÊñΩÔºöÊó†\n"
	if len(userCheckSetting.Punish) > 0 {
		if userCheckSetting.Punish == model.PunishTypeWarning {
			punishMsg = fmt.Sprintf("ÊÉ©ÁΩöÊé™ÊñΩÔºöË≠¶Âëä%dÊ¨°Âêé%s\n", userCheckSetting.WarningCount, utils.PunishActionStr(userCheckSetting.WarningAfterPunish))
		} else {
			punishMsg = fmt.Sprintf("ÊÉ©ÁΩöÊé™ÊñΩÔºö%s\n", utils.PunishActionStr(userCheckSetting.Punish))
		}
	}
	deleteNotifyMsg := fmt.Sprintf("Ëá™Âä®Âà†Èô§ÊèêÈÜíÊ∂àÊÅØ:%s", utils.TimeStr(userCheckSetting.DeleteNotifyMsgTime))
	content += punishMsg + deleteNotifyMsg
	userCheckSetting.ChatId = utils.GroupInfo.GroupId
	services.SaveModel(&userCheckSetting, utils.GroupInfo.GroupId)
	return content
}

// ËèúÂçïÊåâÈíÆÂàùÂßãÂåñÊòæÁ§∫
func updateUserCheckButtonStatus(btn *model.ButtonInfo) {
	if btn.Data == "user_check_name" && userCheckSetting.NameCheck {
		btn.Text = "‚úÖ" + btn.Text
	} else if btn.Data == "user_check_username" && userCheckSetting.UserNameCheck {
		btn.Text = "‚úÖ" + btn.Text
	} else if btn.Data == "user_check_icon" && userCheckSetting.IconCheck {
		btn.Text = "‚úÖ" + btn.Text
	} else if btn.Data == "user_check_subscribe" && userCheckSetting.SubScribe && len(userCheckSetting.ChannelAddr) > 0 {
		btn.Text = "‚úÖ" + btn.Text
	} else if btn.Data == "user_check_name" && !userCheckSetting.NameCheck {
		btn.Text = "‚ùå" + btn.Text
	} else if btn.Data == "user_check_username" && !userCheckSetting.UserNameCheck {
		btn.Text = "‚ùå" + btn.Text
	} else if btn.Data == "user_check_icon" && !userCheckSetting.IconCheck {
		btn.Text = "‚ùå" + btn.Text
	} else if btn.Data == "user_check_subscribe" && !userCheckSetting.SubScribe {
		btn.Text = "‚ùå" + btn.Text
	}
}

func UserValidateCheck(update *tgbotapi.Update, bot *tgbotapi.BotAPI) bool {
	chatId := update.Message.Chat.ID
	setting := model.UserCheck{}
	_ = services.GetModelData(chatId, &setting)

	content := ""
	//Ê£ÄÊü•Áî®Êà∑Âêç
	if setting.UserNameCheck && update.Message.From.UserName == "" {
		content = "Ê≤°ÊúâËÆæÁΩÆÁî®Êà∑Âêç"
	}
	//Ê£ÄÊü•ÂêçÂ≠ó
	if setting.NameCheck && update.Message.From.LastName == "" {
		content = "Ê≤°ÊúâËÆæÁΩÆÂêçÂ≠ó"
	}
	//Ëé∑ÂèñÂ§¥ÂÉè‰ø°ÊÅØ
	profile, _ := bot.GetUserProfilePhotos(tgbotapi.UserProfilePhotosConfig{
		UserID: update.Message.From.ID,
		Limit:  5,
		Offset: 0,
	})
	if setting.IconCheck && profile.TotalCount < 1 {
		content = "Ê≤°ÊúâËÆæÁΩÆÂ§¥ÂÉè"
	}

	// Ê£ÄÊü•ÊòØÂê¶Âú®ÈªëÂêçÂçï‰∏≠
	if len(setting.BlackUserList) > 0 &&
		len(update.Message.From.UserName) > 0 &&
		strings.Contains(setting.BlackUserList, update.Message.From.FirstName) {
		content = "ÊòØÈªëÂêçÂçïÁî®Êà∑"
	}
	if len(content) == 0 {
		return false
	}
	punishment := model.Punishment{
		PunishType:          setting.Punish,
		WarningCount:        setting.WarningCount,
		WarningAfterPunish:  setting.WarningAfterPunish,
		BanTime:             setting.BanTime,
		MuteTime:            setting.MuteTime,
		DeleteNotifyMsgTime: setting.DeleteNotifyMsgTime,
		Reason:              "userCheck",
		ReasonType:          4,
		Content:             content,
	}
	punishHandler(update, bot, punishment)
	return true
}
